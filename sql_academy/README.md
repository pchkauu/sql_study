# [SQL Academy Course](https://stepik.org/course/193691)

## Основы выборки 1


> Литерал - указанное явным образом фиксированное значение

### Оператор LIKE

**LIKE** - оператор, который используется при условных запросах когда необходимо узнать, соответствует ли строка определенному шаблону или нет. Синтаксис: WHERE поле_таблицы (NOT) LIKE шаблон_строки 

Шаблон может включать следующие специальные символы:

| Символ | Описание                                                                                        |
| ------ | ----------------------------------------------------------------------------------------------- |
| %      | Последовательность любых символов (число символов в последовательности может быть от 0 и более) |
| _      | Любой единичный символ                                                                          |

```sql
SELECT name, email FROM Users
WHERE email LIKE '%@hotmail.%'
```
*Запрос на поиск пользователей в домене «hotmail» может выглядеть следующим образом:*

P.S. В MySQL оператор LIKE не чувствителен к регистру  

#### ESCAPE символ

**ESCAPE символ !** - применяется в случае когда необходимо экранировать специальные символы %, \ и _

```sql
SELECT job_id FROM Jobs
WHERE progress LIKE '3!%' ESCAPE '!';
```


### Оператор REGEXP

**REGEXP** - оператор, использующийся для поиска и обработки строковых данных с помощью регулярных выражений. Шаблон: WHERE поле_таблицы REGEXP 'pattern'

#### Важные нюансы

1. По умолчанию регулярные выражения в MySQL не чувствительны к регистру
2. Некоторые символы имеют специальное значение и требуют экранирования символом \


### Оператор ORDER BY

Позволяет отсортировать поля при выборке в заданном порядке

```sql
SELECT поля_таблиц FROM наименование_таблицы
WHERE ...
ORDER BY столбец_1 [ASC | DESC][, столбец_n [ASC | DESC]]
```

ASC и DESC - направления сортировки


### Оператор GROUP BY

**GROUP BY** - используется, когда необходимо сгрупировать выборку по набору определенных полей

```sql
SELECT [литералы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
GROUP BY поля_группировки;
```

При использовании GROUP BY мы можем выводить только литералы, результаты агрегатных функций и поля группировок

P.S. NULL считаются равными

### Агрегатные функции

**Агрегатная функция** - это функция, которая выполняет вычисление на наборе значений и возвращает единичное значение

| Функция                                             | Описание                                                  |
| --------------------------------------------------- | --------------------------------------------------------- |
| AVG(поле_таблицы)                                   | Возвращает среднее значение                               |
| SUM(поле_таблицы)                                   | Возвращает сумму                                          |
| COUNT(поле_таблицы)                                 | Возвращает количество записей                             |
| MIN(поле_таблицы)                                   | Возвращает минимальное значение                           |
| MAX(поле_таблицы)                                   | Возвращает максимальное значение                          |
| TIMESTAMPDIFF(second, поле_datetime, поле_datetime) | Получить разницу во времени в секундах между двумя датами |

### Оператор HAVING

**HAVING** - используется для фильтрации групп при выборке оператором GROUP BY

```sql
SELECT [константы, агрегатные_функции, поля_группировки]
FROM имя_таблицы
WHERE условия_на_ограничения_строк
GROUP BY поля_группировки
HAVING условие_на_ограничение_строк_после_группировки
ORDER BY условие_сортировки
```

#### Порядок выполнения SQL запроса

![[img_1.png]]


## Основы выборки 2

### Многотабличные запросы

В реальности приходится часто делать многотабличные запросы. Общая структура многотабличного запроса:

```sql
SELECT поля_таблиц
FROM таблица_1
[INNER] | [[LEFT, RIGHT, FULL] | OUTER] JOIN таблица_2
ON условие_соединения
[[INNER] | [[LEFT, RIGHT, FULL] | OUTER] JOIN таблица_n
ON условие_соединения_n]
```

Соединение бывает:
1. Внутренним INNER (по умолчанию)
2. Внешним OUTER, которое делится на LEFT, RIGHT и FULL

```sql
SELECT family_member, member_name, amount * unit_price AS price FROM Payments
INNER JOIN FamilyMembers
    ON Payments.family_member = FamilyMembers.member_id
```

Чтобы сопоставление работало, мы указываем как именно записи из двух разных таблиц должны находить друг друга. Это условие указывается после ON

```SQL
ON Payments.family_member = FamilyMembers.member_id
```

> В большинстве случаев условием соединения является равенство столбцов таблиц (таблица_1.поле = таблица_2.поле), однако точно так же можно использовать другие операторы сравнения

#### Вывод всех столбцов из таблицы в многотабличном запросе

Ранее, когда все запросы выполнялись на одной таблице, было достаточно указать символ * , чтобы вывести все поля из этой таблицы. Теперь же, когда таблиц может быть несколько, * будет обозначать "вывести все столбцы из таблиц, перечисленных в выражении FROM". Для того чтобы вывести все столбцы, принадлежащие только к одной конкретной таблицы, можно использовать:

```sql
SELECT FamilyMember.* FROM Payments
```

### Внутренние соединение Inner Join

По умолчанию, если не указаны какие-либо параметры, JOIN выполяется как INNER JOIN, поэтому аргумент INNER является опциональным.

##### Понятие внутренного соединения

Внутреннее соединение - соединение, при котором находятся пары записей из двух таблиц, удовлетворяющие условию соединения, тем самым образуя новую таблицу, содержающую поля из первой и второй исходных таблиц

![[img_2.png]]


Важно: INNER JOIN в результирующей таблице выведет только записи пересечения, а остальные отбросит. OUTER JOIN, в зависимости от правила, выведет 
##### Использование WHERE для соединения таблиц

Для внутреннего соединения таблиц также можно использовать, оператор **WHERE**

```sql
SELECT family_member_id, member_name FROM Payments, FamilyMembers
WHERE Payments.family_member_id = FamilyMembers.member_id
```

### Внешнее соединение Outer Join

Внешнее соединение может быть трёх типов: левое LEFT, правое RIGHT и полное FULL. По умолчанию оно является полным FULL

Главным отличием внешнего соединения от внутреннего является то, что оно обязательно возвращает все строки одной (LEFT, RIGHT) или двух таблиц FULL

##### Внешнее левое соединение LEFT OUTER JOIN

Соединение, которое возвращает все значения из левой таблицы, соединённые с соответствующими значениями из правой таблицы, если они удовлетворяют условию соединения, или заменяет их на NULL в обратном случае

##### Внешнее правое соединение RIGHT OUTER JOIN

То же самое что и LEFT, только берет все записи из правой таблицы

##### Внешнее полное соединение FULL OUTER JOIN

Соединение, которое выполняет внутреннее соединение записей и дополняет их левым внешним соединением и правым внешним соединением

Алгоритм работы полного соединения:
- Формируется таблица на основе внутреннего соединения (INNER JOIN)
- В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN)
- В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN)

> Соединение FULL JOIN реализовано не во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать:
 
```sql
> SELECT *
> FROM левая_таблица
> LEFT JOIN правая_таблица
>    ON правая_таблица.ключ = левая_таблица.ключ
> 
> UNION ALL
> 
> SELECT *
> FROM левая_таблица
> RIGHT JOIN правая_таблица
> ON правая_таблица.ключ = левая_таблица.ключ
>  WHERE левая_таблица.ключ IS NULL
> ```

##### Базовые запросы для разных вариантов объединения таблиц

![[img_3.png]]

### Ограничение выборки, оператор LIMIT

Оператор **LIMIT** позволяет извлечь определённый диапазон записей из одной или нескольких таблиц

```sql
SELECT поля_выборки
FROM список_таблиц
LIMIT [количество_пропущенных_записей], количество_записей_для_вывода
```

Если не указать количество пропущенных записей, то их отсчёт будет вестись с начала таблицы

> Для случаев когда необходимо сделать отступ от начала таблицы, предназначена конструкция **OFFSET FETCH**

Для того чтобы вывести строки с 3 по 5, нужно использовать такой запрос

```sql
SELECT * FROM Company LIMIT 2, 3
```

Или, что то же самое:

```sql
SELECT * FROM Company LIMIT 3 OFFSET 2
```


### Подзапросы

Подзапрос - это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом. Пример:

```sql
SELECT * FROM Reservations
WHERE Reservations.room_id = (
	SELECT id FROM Rooms ORDER BY price DESC LIMIT 1
)
```
